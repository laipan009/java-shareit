DROP TABLE IF EXISTS comments;
DROP TABLE IF EXISTS bookings;
DROP TABLE IF EXISTS items;
DROP TABLE IF EXISTS requests;
DROP TABLE IF EXISTS users;

CREATE TABLE IF NOT EXISTS users
(
    id    BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    name  VARCHAR(255)                            NOT NULL,
    email VARCHAR(60)                             NOT NULL,
    CONSTRAINT pk_user PRIMARY KEY (id),
    CONSTRAINT UQ_USER_EMAIL UNIQUE (email)
);

CREATE TABLE IF NOT EXISTS requests
(
    id           BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    description  VARCHAR(1000)                           NOT NULL,
    requestor_id BIGINT                                  NOT NULL,
    created      TIMESTAMP WITHOUT TIME ZONE             NOT NULL,
    CONSTRAINT pk_request PRIMARY KEY (id),
    CONSTRAINT fk_request_requestor FOREIGN KEY (requestor_id) REFERENCES users (id)
);

CREATE TABLE IF NOT EXISTS items
(
    id           BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    name         VARCHAR(255)                            NOT NULL,
    description  VARCHAR(1000)                           NOT NULL,
    is_available BOOLEAN                                 NOT NULL,
    owner_id     BIGINT                                  NOT NULL,
    request_id   BIGINT,
    CONSTRAINT pk_item PRIMARY KEY (id),
    CONSTRAINT fk_item_owner FOREIGN KEY (owner_id) REFERENCES users (id),
    CONSTRAINT fk_item_request FOREIGN KEY (request_id) REFERENCES requests (id)
);

CREATE TABLE IF NOT EXISTS bookings
(
    id         BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    start_date TIMESTAMP WITHOUT TIME ZONE             NOT NULL,
    end_date   TIMESTAMP WITHOUT TIME ZONE             NOT NULL,
    item_id    BIGINT                                  NOT NULL,
    booker_id  BIGINT                                  NOT NULL,
    status     VARCHAR(255)                            NOT NULL,
    CONSTRAINT pk_booking PRIMARY KEY (id),
    CONSTRAINT fk_booking_item FOREIGN KEY (item_id) REFERENCES items (id),
    CONSTRAINT fk_booking_booker FOREIGN KEY (booker_id) REFERENCES users (id)
);

CREATE TABLE IF NOT EXISTS comments
(
    id        BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    text      VARCHAR(1000)                           NOT NULL,
    item_id   BIGINT                                  NOT NULL,
    author_id BIGINT                                  NOT NULL,
    CONSTRAINT pk_comment PRIMARY KEY (id),
    CONSTRAINT fk_comment_item FOREIGN KEY (item_id) REFERENCES items (id),
    CONSTRAINT fk_comment_author FOREIGN KEY (author_id) REFERENCES users (id)
);

-- ---Functions---
-- --Функция для обновления поля isAvailable предмета после подтверждения бронирования--
-- CREATE OR REPLACE FUNCTION update_item_availability()
--     RETURNS TRIGGER AS
-- $$
-- BEGIN
--     -- Проверяем, был ли статус изменен на APPROVED
--     IF NEW.booking_status = 'APPROVED' AND OLD.booking_status != 'APPROVED' THEN
--         -- Обновляем поле is_available в таблице items
--         UPDATE items
--         SET is_available = FALSE
--         WHERE id = NEW.item_id;
--     END IF;
--     RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;
--
-- --Функция для подсчета доступных предметов--
-- CREATE OR REPLACE FUNCTION CountAvailableItems() RETURNS INT AS
-- $$
-- DECLARE
--     itemCount INT;
-- BEGIN
--     SELECT COUNT(*) INTO itemCount FROM items WHERE is_available = TRUE;
--     RETURN itemCount;
-- END;
-- $$ LANGUAGE plpgsql;
--
--
-- -- Функция для поиска предметов
-- CREATE OR REPLACE FUNCTION SearchItems(searchQuery VARCHAR(255))
--     RETURNS TABLE
--             (
--                 id           BIGINT,
--                 name         VARCHAR(255),
--                 description  VARCHAR(1000),
--                 is_available BOOLEAN,
--                 owner_id     BIGINT,
--                 request_id   BIGINT
--             )
-- AS
-- $$
-- BEGIN
--     RETURN QUERY SELECT id, name, description, is_available, owner_id, request_id
--                  FROM items
--                  WHERE LOWER(name) LIKE LOWER('%' || searchQuery || '%')
--                     OR LOWER(description) LIKE LOWER('%' || searchQuery || '%');
-- END;
-- $$ LANGUAGE plpgsql;
--
-- ---Procedures--
-- -- Процедура для обновления статуса предметов:
-- CREATE OR REPLACE PROCEDURE UpdateItemAvailability()
--     LANGUAGE plpgsql
-- AS
-- $$
-- BEGIN
--     UPDATE items
--     SET is_available = TRUE
--     WHERE id IN (SELECT item_id
--                  FROM bookings
--                  WHERE end_date < NOW()
--                    AND status = 'APPROVED');
-- END;
-- $$;
--
-- -- Процедура для добавления комментария к предмету:
-- CREATE OR REPLACE PROCEDURE AddCommentToItem(itemId INT, userId INT, commentText TEXT)
--     LANGUAGE plpgsql
-- AS
-- $$
-- BEGIN
--     IF EXISTS (SELECT 1
--                FROM bookings
--                WHERE item_id = itemId
--                  AND booker_id = userId
--                  AND status = 'APPROVED') THEN
--         INSERT INTO comments (text, item_id, author_id)
--         VALUES (commentText, itemId, userId);
--     ELSE
--         RAISE EXCEPTION 'User has not booked this item';
--     END IF;
-- END;
-- $$;
--
-- ---Triggers---
-- --Этот триггер будет автоматически обновлять поле is_available в таблице items каждый раз,
-- -- когда соответствующая запись в таблице bookings изменит свой статус на APPROVED.
-- CREATE TRIGGER trigger_update_item_availability
--     AFTER UPDATE OF status
--     ON bookings
--     FOR EACH ROW
--     WHEN (OLD.status IS DISTINCT FROM NEW.status)
-- EXECUTE FUNCTION update_item_availability();
--
-- ---Views---
-- CREATE VIEW UserBookingHistory AS
-- SELECT u.id AS user_id, u.name AS user_name, i.name AS item_name, b.start_date, b.end_date, b.status
-- FROM users u
--          JOIN bookings b ON u.id = b.booker_id
--          JOIN items i ON b.item_id = i.id;